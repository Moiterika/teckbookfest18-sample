# domainパッケージのテストカバレッジを向上させる方針

現在のdomainパッケージのテストカバレッジは27.1%と低めでしたが、`Service仕訳`のテスト実装により52.8%まで向上しました。引き続き以下の方針でテストカバレッジを向上させていきます。

## 1. カバレッジ詳細の確認

カバレッジ情報を取得するコマンド：

```bash
go test -cover -coverprofile=coverage.out ./domain && go tool cover -func=coverage.out
```

### カバレッジ進捗
- 最初: 27.1%
- `Service仕訳`のテスト実装後: 52.8%
- `Service配賦`のテスト実装後: 69.5%
- `Service工数集計`のテスト実装後: 80.3%

## 2. 現在のカバレッジ状況

現在、以下のファイルのみがテストされています：
1. `按分_calc_test.go`
2. `按分結果_entity_test.go`
3. `ordered_map_test.go`

## 3. カバレッジ向上の戦略

カバレッジレポートと未テストファイルを分析した結果、以下の戦略を提案します：

### 優先順位の高い実装すべきテスト

1. **サービスレイヤーのテスト**
   - ✅ `仕訳_service.go` (テスト実装済み)
   - ✅ `工数集計_service.go` (テスト実装済み - カバレッジ92.9%)
   - ✅ `配賦_service.go` (テスト実装済み - カバレッジ77.1%)

2. **エンティティやドメインモデルのテスト**
   - `仕訳_entity.go` (0%)
   - `勘定科目_entity.go` (0%)
   - `按分ルール_entity.go` (0%)
   - `集計仕訳_entity.go` (未カバー)

3. **データ構造のテスト**
   - `按分結果_list.go` (0%)
   - `集計仕訳_list.go` (0%)

### テスト実装アプローチ

#### 1. モックの作成

サービスのテストにはリポジトリのモックが必要です。モックを実装するための方針：

- [testify/mock](https://github.com/stretchr/testify) や [gomock](https://github.com/golang/mock) などのモックライブラリを使用
- インターフェースに対するモックを実装
- リポジトリの振る舞いをモックで制御

#### 2. テーブル駆動テスト

現在の `按分_calc_test.go` のようなテーブル駆動テストを他のコンポーネントにも実装：

- 様々な入力ケース
- エッジケース
- エラーケース

#### 3. 具体的なテストファイル作成計画

テストファイルを以下の順で作成することを推奨します：

1. **基本的なエンティティのテスト**
   - `仕訳_entity_test.go`
   - `勘定科目_entity_test.go`

2. **データ構造のテスト**
   - `按分結果_list_test.go`
   - `集計仕訳_list_test.go`

3. **複雑なドメインロジック**
   - ✅ `仕訳_service_test.go` (実装済み)
   - ✅ `工数集計_service_test.go` (実装済み)
   - ✅ `配賦_service_test.go` (実装済み)

## 4. サンプルテストコード

例として、`仕訳_entity_test.go` の実装例を示します：

```go
package domain

import (
    "testing"
    "time"
    
    "github.com/shopspring/decimal"
    "github.com/stretchr/testify/assert"
)

func Test仕訳Entity(t *testing.T) {
    // エンティティの基本データ
    発生日 := time.Date(2024, 4, 1, 0, 0, 0, 0, time.UTC)
    取引先 := "株式会社テスト"
    摘要 := "テスト仕訳"
    税率 := decimal.NewFromInt(10)
    
    // 仕訳詳細のテストデータ
    詳細 := []詳細{
        {
            勘定科目: "売上高",
            金額:    decimal.NewFromInt(1000),
            部門:    "営業部",
            税区分:   "課税",
        },
        {
            勘定科目: "売掛金",
            金額:    decimal.NewFromInt(1100),
            部門:    "営業部", 
            税区分:   "対象外",
        },
    }
    
    // テスト実行
    仕訳 := New仕訳(発生日, 取引先, 摘要, 詳細)
    
    // アサーション
    assert.Equal(t, 発生日, 仕訳.発生日)
    assert.Equal(t, 取引先, 仕訳.取引先)
    assert.Equal(t, 摘要, 仕訳.摘要)
    assert.Len(t, 仕訳.詳細, 2)
    
    // 詳細のテスト
    assert.Equal(t, "売上高", 仕訳.詳細[0].勘定科目)
    assert.Equal(t, decimal.NewFromInt(1000), 仕訳.詳細[0].金額)
    
    // Keyメソッドのテスト
    key := 仕訳.Key()
    assert.NotEmpty(t, key)
}
```

## 5. 実行計画

1. ✅ `仕訳_service_test.go` の実装 (完了 - カバレッジ52.8%へ向上)
2. ✅ `配賦_service_test.go` の実装 (完了 - カバレッジ69.5%へ向上)
3. ✅ `工数集計_service_test.go` の実装 (完了 - カバレッジ80.3%へ向上)
4. 次に `仕訳_entity_test.go` と `按分結果_list_test.go` の実装を行う
5. テストを実装後、カバレッジを確認
6. カバレッジが低いコンポーネントへの対応を継続

このように段階的にテストを実装することで、全体のカバレッジを向上させることができます。モックの作成や複雑なテストケースの設計などは、実装を進めながら具体化していきましょう。

## 6. 実装済みテスト詳細

### `仕訳_service_test.go`の実装内容

`仕訳_service.go`のテストを実装し、以下の機能をカバーしました：

1. **NewService仕訳** - コンストラクタのテスト
   - 依存関係（リポジトリ・クエリ）が正しくセットされることを確認

2. **Execute仕訳集計** - メインのサービスメソッドテスト
   - 正常系：正常に集計が行われるケース
   - 異常系：CSV読み込みエラーが発生するケース

3. **query仕訳一覧** - 内部メソッドのテスト
   - 正常系：新規仕訳が処理されるケース
   - 異常系：未定義勘定科目があるケース

4. **save** - 保存処理のテスト
   - 正常にデータが保存されるケースをテスト

5. **query集計仕訳** - 集計処理のテスト
   - 対象外の仕訳が除外されることを確認
   - 正しい集計結果が得られることを確認

**テスト実装のポイント：**

- **モックの活用**：外部の依存関係をモック化して単体テストを実現
- **テストダブル**：テスト用のデータ作成ヘルパー関数の作成
- **エラー検証**：想定されるエラーケースの網羅
- **状態検証**：戻り値の検証と内部状態の確認

**カバレッジ向上：**
- 27.1% → 52.8% （+25.7%）

### `配賦_service_test.go`の実装内容

`配賦_service.go`のテストを実装し、以下の機能をカバーしました：

1. **NewService配賦** - コンストラクタのテスト
   - 依存オブジェクトが正しくセットされることを確認

2. **Query按分ルール一覧** - 按分ルールの取得テスト
   - 正常系：按分ルールが正常に取得できるケース
   - 異常系：按分ルール読み込みでエラーが発生するケース

3. **Execute配賦** - 配賦処理のテスト
   - 直課の場合：按分せずに直接コピーされるケース
   - 按分の場合：按分ルールに基づいて按分されるケース
   - 按分誤差の場合：按分で誤差が生じるが正しく調整されるケース
   - エラーケース：按分ルールが未定義の場合や保存エラーの場合

**テスト実装のポイント：**

- **モックの活用**：Rep按分ルール, Cmd按分結果明細, Cmd按分結果のモック化
- **モック関数の検証**：呼び出されるメソッドと引数の検証
- **結果の検証**：按分結果の正確性を検証（金額、直課/間接費の識別など）
- **エラーケースの網羅**：様々なエラーパターンのテスト

**カバレッジ向上：**
- 52.8% → 69.5% （+16.7%）

### `工数集計_service_test.go`の実装内容

`工数集計_service.go`のテストを実装し、以下の機能をカバーしました：

1. **NewService工数集計** - コンストラクタのテスト
   - 依存オブジェクト（勤務表Reader、按分ルールIo）が正しくセットされることを確認

2. **Execute工数集計** - 工数集計処理のテスト
   - 正常系：勤務表データから労務費工数と経費工数が正しく集計され、按分ルールが作成されるケース
   - 勤務表読み込みエラー系：勤務表の読み込みでエラーが発生するケース
   - 按分ルール保存エラー系：按分ルールの保存でエラーが発生するケース

**テスト実装のポイント：**

- **専用モックの作成**：名前衝突を避けるため、`Mock工数Qry勤務表`と`Mock工数Rep按分ルール`として専用モックを実装
- **正確なデータ検証**：集計結果が正確であることを確認（プロジェクト、計上月ごとの集計値）
- **ソート検証**：按分ルール一覧が適切にソートされることの確認
- **エラー状態の検証**：エラー発生時の戻り値と副作用の検証

**カバレッジ向上：**
- 69.5% → 80.3% （+10.8%）
- `工数集計_service.go`のExecute工数集計メソッドは92.9%のカバレッジを達成
